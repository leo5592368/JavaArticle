# Java多线程不完全指南 #
## 序言 ##
最近常在简书上看些文章，被这样的一个分享平台吸引了，就想着写点什么。在提升自己对很多薄弱知识理解的同时，也能与人交流学习一二。

想了一段时间，与人分享交流点什么呢？从多线程开始吧，我理解很不深入的一块内容，也是工作中很重要的内容。本文主要介绍Java多线程涉及的众多概念，并会在后续文章逐步对每一块内容做深入分析。

## 必备基础知识 ##
### 线程与进程 ###
- 线程：是操作系统能够进行运算调度的最小单位，是进程中的实际运作单位。一条线程是进程中一个单一顺序的控制流。
- 进程：是计算机中已运行程序的实体，是线程的容器。
### 同步与异步 ###
- 同步：在发出一个调用时，在没有得到结果之前，该调用就不返回。一旦返回，必然会得到返回值。
- 异步：在调用发出之后，这个调用就直接返回。随后，被调用者通过状态、通知来通知调用者，或者通过回调函数来处理调用。

同步与异步关注的是消息通信机制。
### 阻塞与非阻塞 ###
- 阻塞：调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
- 非阻塞：调用在不能立刻得到结果之前，该调用不会阻塞当前线程，当前线程仍会处理其他调用。

阻塞与非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。
### 并行与并发 ###
- 并发：在同一个处理器上“同时”处理多个任务。通过cpu调度算法，让用户看上去是同时处理。
- 并行：在多台机器上同时处理多个任务，真正的同时。
### 多线程与线程安全 ###
- 多线程:一个程序实现多个线程并发执行。
- 线程安全:多个线程同时执行同一段代码，线程的调度顺序不会影响该段代码的任何结果。线程安全主要通过线程同步实现。

## 线程的状态 ##
### 5种状态 ###
根据线程的生命周期，可以将线程分为以下5种状态：

1. NEW(新建)：创建了一个线程，尚未启动
2. RUNNABLE(可运行)：线程创建后，其他线程调用了该线程的`start()`方法，该线程便等待被CPU调度执行。
3. RUNNING（运行）：RUNNABLE状态的线程被CPU调度，获取了CPU时间片，运行`run()`方法。
4. BLOCKERD（阻塞）：线程无法获取CPU时间片，暂时停止运行的状态。这个状态的线程只有状态转为RUNNABLE时，才有机会被CPU调度执行。阻塞有三种情况：
    1. 等待阻塞：如RUNNING状态的线程执行`wait()`方法。
    2. 同步阻塞：如RUNNING状态的线程在获取同步锁时，同步锁被其他线程占用。
    3. 其他阻塞：如RUNNING状态的线程执行`sleep()`方法或其他线程调用`join()`方法。
5. DEAD(死亡)：线程`run()`方法执行结束或异常退出，该线程死亡，结束生命周期。
### 状态转换 ###
![线程状态转换](http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg)
### Thread类定义的线程状态 ###
### VisualVM线程监控 ###

## 内存可见性与原子性 ##
### Java内存模型 ###
#### 概念 ####
1. 线程之间通信由Java内存模型控制，内存模型决定了一个线程对共享变量的写入何时对另一个线程可见。
2. 每个线程都被抽象出一个保存共享变量副本的工作内存，线程对共享变量的操作都在此工作内存中进行。
3. 某个线程无法直接访问其他线程中的变量，线程之间的通信需要通过主内存来实现。
![Java内存模型](http://ifeve.com/wp-content/uploads/2013/01/113.png)
#### 线程通信过程 ####
1. 线程A从主内存中拷贝共享变量1到工作内存中的副本，对副本的值进行修改。
2. 线程A刷新修改后的值到主内存中。
3. 线程B将主内存中共享变量1拷贝到工作内存中。
### 并发编程三个特征 ###
- 原子性：类似于数据库事务，要么全部执行，要么不执行。
	如：`num++`不具有原子性，先取出num的值，再进行加1。
	而`a=1`,`return a`则都具有原子性。
- 可见性：某个线程对共享变量做了修改后，其他线程可以立马感知到该变量的修改。
- 有序性：若在本线程内观察，所有操作都是有序的；若在一个线程中观察其他线程，所有的操作都是无序的。前半句指“线程内表现为串行语义”，后半句指“指令重排序”现象和“工作内存中主内存同步延迟”现象。
### Sychronized与Volatile ###
- Sychronized：可以保证原子性、可见性和有序性。
	Sychronized关键字能保证在同一时刻，只有一个线程可以获取锁执行同步代码，执行完之后释放锁之前，会将修改后变量的值刷新的主内存中。
- Volatile：可以保证可见性和有序性，不能保证操作的原子性。
	被Volatile关键字修饰的变量，在写操作后会加入一条store指令，强行将共享变量最新的值刷新到主内存中。在读操作前，会加入一条load指令，强行从主内存中读取共享变量最新的值。
### Java锁机制 ###
#### Java中的锁 ####
- Sychronized
- ReentrantLock
- ReentrantReadWriteLock

这三种锁是怎么实现的？什么是AQS？什么是CAS？CAS的ABA问题怎么解决？

## Java多线程类 ##
### 1.基本线程类 ###
### 2.高级线程控制类 ###

## Java线程池 ##